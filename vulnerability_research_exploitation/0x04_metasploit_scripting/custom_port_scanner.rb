#!/usr/bin/env ruby

require 'msf/core'

module Msf
	module Auxiliary
		class CustomPortScanner < Msf::Auxiliary
			include Msf::Auxiliary::Scanner

			def initialize
				super(
					'Name' => 'Escanea un rango de puertos en un sistema objetivo y muestra los puertos abiertos',
					'Author' => 'toleman',
					'License' => MSF_LICENSE
					)

				# opciones del módulo
				register_options(
				[
					Opt::RHOST(),
					OptInt.new('STARTPORT', [true, 'Puerto inicial del rango', 20]),
					OptInt.new('ENDPORT', [true, 'Puerto final del rango', 10000])
					]
				)
				end

			def run_host(ip)
				start_port = datastore['STARTPORT']
				end_port = datastore['ENDPORT']

				# validar rango de puertos
				if start_port > end_port
					print_error("STARTPORT no puede ser mayor que ENDPORT")
					return
				end

				print_status("Escaneando puertos del #{start_port} al #{end_port} en #{ip}...")

				open_ports = []

				(start_port..end_port).each do |port|
				begin
					sock = connect(nil, ip, port, 1)
					if sock
						print_good("#{ip}:#{port} - El puerto #{port} está abierto")
						open_ports << port
					end
				rescue Rex::ConnectionError
					# Si el puerto está cerrado o no responde, ignorarlo
				    ensure
					    disconnect(sock) if sock
				    end
				end
							
				if open_ports.empty?
					print_status("No se encontraron puertos abiertos en #{ip}.")
				else
					print_status("Puertos abiertos en #{ip}: #{open_ports.join(', ')}")
				end
			end
		end
	end
end
